#version 450
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(binding = 0) uniform CameraBlock {

    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;
} camera;

layout (binding = 1, rgba8) uniform image2D colorBuffer;


struct Ray {
    vec3 Origin;
    vec3 Direction;
};

struct HitPayload {
    
    float HitDistance;
    vec3 WorldPos;
    vec3 WorldNormal;
};

struct Sphere {
    
    vec3 Pos;
    float Radius;
};

struct Material {
	vec3 Albedo;
	float Roughness;
	float Metallic;
	vec3 EmissionColor;
	float EmissionPower;
};

HitPayload TraceRay(Ray ray, Sphere sphere);
HitPayload ClosestHit(Ray ray, float hitDistance, Sphere sphere);
HitPayload Miss(Ray ray);

void main() {

    ivec2 screenPos = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    ivec2 screenSize = imageSize(colorBuffer);

	vec2 uv = vec2(float(screenPos.x) / float(screenSize.x), 1.0 - float(screenPos.y) / float(screenSize.y)); // uv with 0,0 in bottom left corner
	vec2 coord = uv * 2.0f - 1.0f; // -1 -> 1


    // Scene stuff
    vec3 cameraPos = vec3(0.0, 0.0, -2.0);

    Material mat;
    mat.Albedo = vec3(1.0, 0.0, 0.0);
    mat.Roughness = 1.0;
    mat.Metallic = 0.0;
    mat.EmissionColor = vec3(1.0, 0.0, 0.0);
    mat.EmissionPower = 0.5;

    Sphere sphere;
    sphere.Pos = vec3(0.0, 0.0, 2.0);
    sphere.Radius = 1.0;
    
	vec3 light = vec3(0.0);
	vec3 contribution = vec3(1.0);

    // Ray trace stuff
    Ray ray;
    ray.Origin = cameraPos;
    ray.Direction = vec3(coord.x, coord.y, 1.0);

    int bounces = 1;
	for (int i = 0; i < bounces; i++) {

		HitPayload payload = TraceRay(ray, sphere);
		if (payload.HitDistance < 0.0) {
            
			break;
		}
        
		contribution *= mat.Albedo;
		light += mat.EmissionColor * mat.EmissionPower;

		ray.Origin = payload.WorldPos + payload.WorldNormal * 0.0001f;
		// ray.Direction = normalize(Walnut::Random::InUnitSphere() + payload.WorldNormal);
	}

    imageStore(colorBuffer, screenPos, vec4(light, 1.0));
}

HitPayload TraceRay(Ray ray, Sphere sphere) {

    vec3 origin = ray.Origin - sphere.Pos;

	float a = dot(ray.Direction, ray.Direction);
	float b = 2.0f * dot(ray.Direction, origin);
	float c = dot(origin, origin) - sphere.Radius * sphere.Radius;

	float discriminant = b * b - 4 * a * c;

	if (discriminant < 0)
		return Miss(ray);
	
	float t = (-b - sqrt(discriminant)) / (2.0f * a);

	if (t > 0.0f) {
        return ClosestHit(ray, t, sphere);
	}

    return Miss(ray);
}

HitPayload Miss(Ray ray) {
    
    HitPayload payload;
    payload.HitDistance = -1.0;
    return payload;
}

HitPayload ClosestHit(Ray ray, float hitDistance, Sphere sphere) {
    
    HitPayload payload;

	payload.HitDistance = hitDistance;
	vec3 origin = ray.Origin - sphere.Pos;
	vec3 relPos = origin + ray.Direction * hitDistance;
	payload.WorldPos = relPos + sphere.Pos;
	payload.WorldNormal = normalize(relPos);

    return payload;
}